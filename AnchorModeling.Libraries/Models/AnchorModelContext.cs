using AnchorModeling.Attributes;
using AnchorModeling.Entities;
using EntityFrameworkCore.Attributes;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Storage;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using static AnchorModeling.Names;

namespace AnchorModeling.Models
{
    public abstract class AnchorModelContext : DbContext
    {
        public AnchorModelContext() { }
        public AnchorModelContext(DbContextOptions<AnchorModelContext> options) : base(options) { }

        private Transaction _transaction = null;

        [AnchorIgnore]
        public DbSet<Source> Sources { get; set; }
        [AnchorIgnore]
        public DbSet<Transaction> Transactions { get; set; }

        public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default)
        {
            (List<AuditEntry> Temporary, List<AuditEntry> All) = OnBeforeSaveChanges(acceptAllChangesOnSuccess, cancellationToken);
            var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
            OnAfterSaveChanges(Temporary, acceptAllChangesOnSuccess, cancellationToken);
            await SaveAsAnchor(All, acceptAllChangesOnSuccess, cancellationToken);
            return result;
        }

        public async Task<AnchorTransaction> BeginTransactionAsync(Transaction transaction)
        {
            lock (this)
            {
                if (_transaction != null) throw new TransactionNotClosedException();
            }
            _transaction = transaction;

            var trn = await Database.BeginTransactionAsync();

            Transactions.Add(_transaction);
            await base.SaveChangesAsync();

            return new AnchorTransaction(this, trn, _transaction);
        }

        private (List<AuditEntry> TemporaryEntries, List<AuditEntry> AllEntries) OnBeforeSaveChanges(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default)
        {
            ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();

            foreach (EntityEntry entry in ChangeTracker.Entries())
            {
                if (entry.Entity is Transaction || entry.Entity is Source ||
                    entry.State == EntityState.Detached || entry.State == EntityState.Unchanged) continue;

                var auditEntry = new AuditEntry(entry);

                auditEntries.Add(auditEntry);

                foreach (PropertyEntry property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    var propertyName = property.Metadata.Name;

                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        auditEntry.PkValue = (int)property.CurrentValue;
                        continue;
                    }

                    auditEntry.EntityState = entry.State;

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            if (property.CurrentValue == null) break;
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                            {
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            return (auditEntries.Where(_ => _.HasTemporaryProperties).ToList(), auditEntries);
        }

        private void OnAfterSaveChanges(List<AuditEntry> auditEntries, bool acceptAllChangesOnSuccess, CancellationToken cancellationToken)
        {
            if (auditEntries == null || auditEntries.Count == 0) return;

            foreach (AuditEntry auditEntry in auditEntries)
                // Get the final value of the temporary properties
                foreach (PropertyEntry prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                        auditEntry.PkValue = (int)prop.CurrentValue;
                    }
                    else auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                }
        }

        private async Task SaveAsAnchor(List<AuditEntry> auditEntries, bool acceptAllChangesOnSuccess, CancellationToken cancellationToken)
        {
            var thatType = GetType();
            var assembly = thatType.Assembly;
            var nameSpace = thatType.Namespace;

            //put data to anchor model
            foreach (AuditEntry entity in auditEntries)
            {
                //Anchor
                int A_Id = 0;
                switch (entity.EntityState)
                {
                    case EntityState.Added:
                        {
                            var anchorTable = entity.Entry.Metadata.ClrType.GetCustomAttribute<AnchorTypeAttribute>().TypeName;
                            var anchorType = assembly.GetType($"{nameSpace}.{anchorTable}", true, false);
                            var anchInstance = Activator.CreateInstance(anchorType);

                            anchorType.GetProperty(TransactionIdFKName).SetValue(anchInstance, _transaction.Id);
                            anchorType.GetProperty(Id).SetValue(anchInstance, entity.PkValue);

                            A_Id = entity.PkValue;

                            Entry(anchInstance).State = EntityState.Added;
                        }
                        break;
                    case EntityState.Modified:
                        A_Id = entity.PkValue;
                        break;
                    case EntityState.Deleted:
                        {
                            var anchorTable = entity.Entry.Metadata.ClrType.GetCustomAttribute<AnchorTypeAttribute>().TypeName;
                            var anchorType = assembly.GetType($"{nameSpace}.{anchorTable}", true, false);
                            var anchInstance = await FindAsync(anchorType, entity.PkValue);

                            anchorType.GetProperty(Id).SetValue(anchInstance, entity.PkValue);
                            anchorType.GetProperty(CloseTransactionIdFKName).SetValue(anchInstance, _transaction.Id);

                            Entry(anchInstance).State = EntityState.Modified;

                            await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
                            return;
                        }
                    default: throw new StateNotSupportsException(entity.EntityState.ToString());
                }

                foreach (var k in entity.NewValues.ToList())
                {
                    var entryType = entity.Entry.Metadata.ClrType;
                    var prop = entryType.GetProperty(k.Key);
                    var isTemporary = prop.IsDefined(typeof(TemporaryAttribute));

                    if (prop.IsDefined(typeof(TieTypeAttribute)))
                    {
                        var tieSig = prop.GetCustomAttribute<TieTypeAttribute>().TypeName;
                        var tieType = assembly.GetType($"{nameSpace}.{tieSig}", true, false);

                        if (tieType == null) throw new TypeNotFoundException(tieSig);

                        var tieInstance = Activator.CreateInstance(tieType);

                        tieType.GetProperty(Names.A_Id).SetValue(tieInstance, A_Id);

                        if (isTemporary)
                        {
                            var applTime = (DateTime)entryType.GetField(When).GetValue(entity.Entry);
                            tieType.GetProperty(When).SetValue(tieInstance, applTime);
                        }

                        tieType.GetProperty(ToId).SetValue(tieInstance, k.Value);
                        tieType.GetProperty(TransactionIdFKName).SetValue(tieInstance, _transaction.Id);

                        Entry(tieInstance).State = EntityState.Added;

                        continue;
                    }

                    //Anchors attributes
                    var propertyTableName = prop.GetCustomAttribute<AttributeTypeAttribute>().TypeName;
                    var propType = assembly.GetType($"{nameSpace}.{propertyTableName}", true, false);

                    if (propType == null) throw new TypeNotFoundException(propertyTableName);

                    var propInstance = Activator.CreateInstance(propType);

                    propType.GetProperty(Names.A_Id).SetValue(propInstance, A_Id);
                    propType.GetProperty(TransactionIdFKName).SetValue(propInstance, _transaction.Id);

                    if (isTemporary)
                    {
                        DateTime applTime = (DateTime)entryType.GetField(When).GetValue(entity.Entity);
                        propType.GetProperty(When).SetValue(propInstance, applTime);
                    }

                    propType.GetProperty(Value).SetValue(propInstance, k.Value);

                    Entry(propInstance).State = EntityState.Added;
                }
            }

            await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder) => modelBuilder.BindCompositeKey();

        public class AnchorTransaction : IDisposable
        {
            private readonly AnchorModelContext _dbContext;
            private readonly IDbContextTransaction _dbContextTransaction;

            public AnchorTransaction(AnchorModelContext dbContext,
                IDbContextTransaction DbContextTransaction,
                Transaction transaction)
            {
                _dbContext = dbContext;
                _dbContext._transaction = transaction;
                _dbContextTransaction = DbContextTransaction;
            }

            public void Commit() => _dbContextTransaction.Commit();

            private bool isDisposed = false;
            public void Dispose()
            {
                if (!isDisposed)
                {
                    try { }
                    finally
                    {
                        _dbContextTransaction?.Dispose();
                        if (_dbContext != null)
                        {
                            _dbContext._transaction = null;
                        }
                        isDisposed = true;
                    }
                }
            }
        }
    }
}